// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
#include "ctre/Phoenix.h"

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<WPI_TalonSRX> RobotMap::driveTrainleftFront;
std::shared_ptr<WPI_TalonSRX> RobotMap::driveTrainleftBack;
std::shared_ptr<WPI_TalonSRX> RobotMap::driveTrainrightFront;
std::shared_ptr<WPI_TalonSRX> RobotMap::driveTrainrightBack;
std::shared_ptr<WPI_TalonSRX> RobotMap::liftController;
std::shared_ptr<frc::MecanumDrive> RobotMap::driveTrainMecanumDrive1;
std::shared_ptr<AnalogGyro> RobotMap::gyro;

AHRS *RobotMap::ahrs;
frc::Preferences *prefs;
double RobotMap::turnP;
double RobotMap::turnI;
double RobotMap::turnD;
double RobotMap::driveP;
double RobotMap::driveI;
double RobotMap::driveD;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	frc::LiveWindow *lw = frc::LiveWindow::GetInstance();

	driveTrainleftFront.reset(new WPI_TalonSRX(12));

	driveTrainleftBack.reset(new WPI_TalonSRX(11));

	driveTrainrightFront.reset(new WPI_TalonSRX(13));

	driveTrainrightBack.reset(new WPI_TalonSRX(14));

	liftController.reset(new WPI_TalonSRX(0));

	RobotMap::driveTrainleftBack->Set(ControlMode::Follower, 12);

	RobotMap::driveTrainrightBack->Set(ControlMode::Follower, 11);

	RobotMap::driveTrainleftFront->ConfigSelectedFeedbackSensor(
			FeedbackDevice::QuadEncoder, 0, 5);

	driveTrainMecanumDrive1.reset(
			new frc::MecanumDrive(*driveTrainleftFront, *driveTrainleftBack, *driveTrainrightFront, *driveTrainrightBack));
	lw->AddActuator("DriveTrain", "Mecanum Drive 1", driveTrainMecanumDrive1);
	driveTrainMecanumDrive1->SetSafetyEnabled(true);
	driveTrainMecanumDrive1->SetExpiration(0.1);
	driveTrainMecanumDrive1->SetMaxOutput(1.0);

	RobotMap::driveTrainrightFront->ConfigSelectedFeedbackSensor(
			FeedbackDevice::QuadEncoder, 0, 5);
	try {
		/***********************************************************************
		 * navX-MXP:
		 * - Communication via RoboRIO MXP (SPI, I2C, TTL UART) and USB.
		 * - See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface.
		 *
		 * navX-Micro:
		 * - Communication via I2C (RoboRIO MXP or Onboard) and USB.
		 * - See http://navx-micro.kauailabs.com/guidance/selecting-an-interface.
		 *
		 * Multiple navX-model devices on a single robot are supported.
		 ************************************************************************/
		ahrs = new AHRS(SPI::Port::kMXP);
	} catch (std::exception& ex) {
		std::string err_string = "Error instantiating navX MXP:  ";
		err_string += ex.what();
		//DriverStation::ReportError(err_string.c_str());
	}


	prefs = Preferences::GetInstance();
	turnP = prefs->GetDouble("Turn P", 0.04f);
	turnI = prefs->GetDouble("Turn I", 0.01f);
	turnD = prefs->GetDouble("Turn D", 0.02f);

	prefs->PutDouble("Turn P", turnP);
	prefs->PutDouble("Turn I", turnI);
	prefs->PutDouble("Turn D", turnD);


	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
