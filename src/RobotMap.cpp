// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
//#include "LiveWindow/LiveWindow.h"
#include "ctre/Phoenix.h"
#include "DriverStation.h"

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLlUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<WPI_TalonSRX> RobotMap::driveTrainleftFront;
std::shared_ptr<WPI_TalonSRX> RobotMap::driveTrainleftBack;
std::shared_ptr<WPI_TalonSRX> RobotMap::driveTrainrightFront;
std::shared_ptr<WPI_TalonSRX> RobotMap::driveTrainrightBack;
std::shared_ptr<WPI_TalonSRX> RobotMap::liftController;
std::shared_ptr<WPI_TalonSRX> RobotMap::intake;
std::shared_ptr<WPI_TalonSRX> RobotMap::shaftController;
std::shared_ptr<frc::MecanumDrive> RobotMap::driveTrainMecanumDrive1;
std::shared_ptr<AnalogPotentiometer> RobotMap::pot;
std::shared_ptr<AnalogInput> RobotMap::analogInput;
std::shared_ptr<Relay> RobotMap::shaftOrRampRelay;


AHRS *RobotMap::ahrs;
frc::Preferences *prefs;
double RobotMap::turnP;
double RobotMap::turnI;
double RobotMap::turnD;
double RobotMap::driveP;
double RobotMap::driveI;
double RobotMap::driveD;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	//frc::LiveWindow *lw = frc::LiveWindow::GetInstance();

	analogInput.reset(new AnalogInput(0));
#ifdef TEST_BOT

	driveTrainleftFront.reset(new WPI_TalonSRX(12));

	driveTrainleftBack.reset(new WPI_TalonSRX(11));

	driveTrainrightFront.reset(new WPI_TalonSRX(13));

	driveTrainrightBack.reset(new WPI_TalonSRX(14));

#else//Real bot
	DriverStation::ReportError("Real BOT!");

	driveTrainleftFront.reset(new WPI_TalonSRX(15));
	//driveTrainleftFront->SetInverted(true);

	driveTrainleftBack.reset(new WPI_TalonSRX(3));
	//driveTrainleftBack->SetInverted(true);

	driveTrainrightFront.reset(new WPI_TalonSRX(4));
	//driveTrainrightFront->SetInverted(true);

	driveTrainrightBack.reset(new WPI_TalonSRX(7));
	//driveTrainrightBack->SetInverted(true);

#endif

	shaftOrRampRelay.reset(new Relay(/* FIXME put proper channel */0));
	//shaftOrRampRelay->SetExpiration(5);

	intake.reset(new WPI_TalonSRX(18));
	shaftController.reset(new WPI_TalonSRX(16));

	pot.reset(new AnalogPotentiometer(analogInput, 1.0, 0.0));

#ifdef TEST_BOT
	RobotMap::driveTrainleftFront->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 5);
#else
	RobotMap::driveTrainrightBack->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 5);
	RobotMap::driveTrainleftBack->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 1, 5);
#endif
	driveTrainMecanumDrive1.reset(new frc::MecanumDrive(*driveTrainleftFront, *driveTrainleftBack, *driveTrainrightFront, *driveTrainrightBack));
	//lw->AddActuator("DriveTrain", "Mecanum Drive 1", driveTrainMecanumDrive1);
	driveTrainMecanumDrive1->SetSafetyEnabled(true);
	driveTrainMecanumDrive1->SetExpiration(0.1);
	driveTrainMecanumDrive1->SetMaxOutput(1.0);

	RobotMap::shaftController->SetInverted(true);

	try {
		/***********************************************************************
		 * navX-MXP:
		 * - Communication via RoboRIO MXP (SPI, I2C, TTL UART) and USB.
		 * - See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface.
		 *
		 * navX-Micro:
		 * - Communication via I2C (RoboRIO MXP or Onboard) and USB.
		 * - See http://navx-micro.kauailabs.com/guidance/selecting-an-interface.
		 *
		 * Multiple navX-model devices on a single robot are supported.
		 ************************************************************************/
		ahrs = new AHRS(SPI::Port::kMXP);
	} catch (std::exception& ex) {
		std::string err_string = "Error instantiating navX MXP:  ";
		err_string += ex.what();
		DriverStation::ReportError(err_string.c_str());
	}

	prefs = Preferences::GetInstance();
#ifdef TEST_BOT
	turnP = prefs->GetDouble("Turn P", 0.04f);
	turnI = prefs->GetDouble("Turn I", 0.01f);
	turnD = prefs->GetDouble("Turn D", 0.02f);
#else
	turnP = prefs->GetDouble("Turn P", 0.07f);
	turnI = prefs->GetDouble("Turn I", 0.0f);
	turnD = prefs->GetDouble("Turn D", 0.0315f);
#endif
	prefs->PutDouble("Turn P", turnP);
	prefs->PutDouble("Turn I", turnI);
	prefs->PutDouble("Turn D", turnD);
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

}
